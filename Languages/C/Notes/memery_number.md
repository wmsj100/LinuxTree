---
title: 内存中的整数
date: 2019-04-13 18:24:10	
modify: 
tag: [number,mem,system,Linux]
categories: C
author: wmsj100
mail: wmsj100@hotmail.com
---

# 内存中的整数

## 概述
- 加法和减法是计算机最基本的运算，所以他们是计算机硬件支持的。
- 为了简化硬件电路，减法也是通过加法来模拟实现的 (10-2 => 10 + (-2))
- 当前计算机就是通过这样来实现的

## 原码
- 就是一个整数转换成二进制的形式，
- 原码就是整数的二进制形式

## 反码
- 正数: 正数的原码和反码一样
- 负数: 负数的反码是将原码中除符号位以外的所有位(数值位)取反，也就是0=>1,1=>0;
- 解决了小值-大值的运算过程
- 5-13 = 5+(-13) = -8
- 无法解决大值-小值的问题，得出的值始终小1，是因为运算过程中数据溢出了，溢出后内存就直接截掉了，导致运算错误
- 13-5 = 13+(-5) = 7 

## 补码
- 正数: 补码就是原码(原码/反码/补码都一样)
- 负数: 补码是反码加1
- 补码是为了应对反码运算小1的问题，因为数据溢出后导致数据小1，所以补码就是在反码的基础上直接加1，这样可以应对所有数据运算

## 总结
- 在计算机内存中，整数一律采用补码的形式来存储，这意味着读取整数时候要采用逆向的转换，也就是 补码>反码>原码
- 因为数值都是以补码形式存储，所以所有关于数值的运算都是以补码形式运算，只有在读取的时候才会把补码转换为原码

## 特殊值
- -128转换为补码过程： 
	- 原码： 最高位会覆盖符号位，数值位全部为0
	- 反码： 数值位全部取反，都为1
	- 补码： 数值位+1，数值溢出，符号位被覆盖1次，数值位全部为0
	- 所以规定 10000000 就标识-128，因为从 -128可以推出1000 0000，但是，反过来不行

## 参考
- [整数在内存中的存储](http://c.biancheng.net/cpp/html/3098.html)
