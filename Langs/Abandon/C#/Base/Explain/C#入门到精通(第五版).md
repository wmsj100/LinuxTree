
### study node
---

Common Intermediate Language，CIL -- 中间语言
Active Server Pages .NET(ASP.NET)
 Active Data Objects.NET(ADO.NET)
 C#的LINQ(Language Integrated Query) 语言统一查询
 Object-Oriented(倾向于) Programming，OOP 面向对象编程

Console.ReadKey(); -- 表示当程序执行完成之后等待用户按键来结束；
Console.WriteLine("hello world"); -- 输出一行。

所有C#文件都使用'.cs'文件扩展名。

对于控制台应用，这个应该是少，因为就是弹出一个命令行，而且执行完成之后会自动关闭，所以需要添加一句 'Console.ReadKey()'，表示执行完成之后需要通过按键来确认关闭。

对于窗口应用，可以很方便的通过拖动控件来实现视觉效果，
'MessageBox.Show("This is the first button")' -- 这个就类似于'alert'功能。

注释的方式类似于`js`
// -- 当行注释
/* .... */ -- 多行注释

C#区分大小写

---
// 可以折叠之间的代码
#region Using directives(指针，管理)
...
#endregion

---

声明变量 <type> <name>

整数类型
sbyte, byte, short, ushort, int, uint, long, ulong;
u -- unsigned 表示不能存储负数

浮点数类型
float, double, decimal

简单类型： 数值类型(整数， 浮点数)，char(0-65535)， bool(布尔值), string.
其中`string`的字符数没有上限，因为它可以使用可变大小的内存。

---

字符串的内容必须要使用'"'双引号括起来，如果内容中出现双引号，需要通过'\
'进行转义。
`myString = "\"myInteger\" is";`

---

定义变量之后，如果要在控制台输出已经赋值的变量，需要使用`Console.WriteLine`,其值可以使用占位符的方式来使用，占位符被双引号包裹，是'{num}'的类型，其值就是后面的参数的下标，以'0'开始。

---

### 命名约定
有俩种方式，`camelCase` && `PascalCase`
- 简单的变量 -- 使用`camelCase`；
- 高级的变量 -- 就像`js`中的构造函数，就使用`PascalCase`；函数声明就使用这个。

---

对于字符串的转义，可以通过使用-- 逐字指定的字符串的方式。
就是在字符串的前面添加符号`@`;

---

对于变量，在使用前必须先进行初始化，就是需要提前声明变量的类型，然后给变量赋值，这一点是和js有明显的区别的，
也就是说，假如我声明的变量类型为`int`，但是我赋值时候给了一个字符串，这时候编译器就会提示错误。
而在js中可以随便的更改值的类型。

当然声明和赋值的过程也可以简化，如下
`int x = 10, y = 20;`
就是一次可以同时声明多个变量，并且在声明的过程中进行赋值。

---

### 表达式
表达式就是通过运算符把变量和字面值连接起来。
一元运算符--- + 运算符比较奇怪，不像js中会把负值转换为正值，暂时好像没有作用
二元运算符 -- + 只有它可以处理字符串

---

int var1, var2 = 5, var3 = 6;
var1 = var2++ * --var3;
对于上面的运算，只需要考虑`var3`,因为`var2++`这个只会影响到`var2`，`var2++ === var2`。
等价于 == `var1 = 5 * 5 = 25;

---

Console.ReadLine(); -- 提示用户输入，并把它们存储在string变量中。
所以如果需要使用用户输入的数值，那么在使用前需要进行类型转换。 
`Convert.ToDouble(Console.ReadLine())`;
对于参数，可以使用表达式，
`Console.WriteLine("{0} - {1} = {2}", fNum, sNum, fNum - sNum)`;

---

### 运算符优先级
++, -- (前缀)； +, -(一元)；
*, /, %;
+, -;
=, +=, -=, *=, /=, %=;
++, --(后缀)

---

### 名称空间
我感觉这个和js的命名空间应该类似吧，
Systen 是.Net Framework应用程序的根命名空间。包含控制台应用程序需要的所有基本功能。

---

### 第四章 流程控制

基本都和js类似，但是有 -- 布尔赋值运算符，
`&=` => `var1 &= var2` == `var1 = var1 & var2`;
Console.ReadLine() 获取到的是字符串，
Convert.ToInt32(); -- 可以把存储的用户输入的字符串转换为数值。

goto语句： 类似标签，可以跳转到标签，这个和js中的跳出循环时候使用的标签类似，不过这个是直接跳到标签位置，中间的代码就被跳过去了。
goto语句中断正常的执行过程，把控制权转到标有`myLabel:`的代码行上。
因为goto语句会让代码变得晦涩难懂，所以不要使用它，就像js中的`width`一样

---

#### 分支
C#中有3种分支技术：
三元运算符 -- 适用于比较结果执行简单代码的的情形，
if语句 -- 用于处理结果执行大量代码的情形；
switch语句

- 常见错误 `if(a == 3 || a == 4){}` 错误的写为 `if(a == 3 || 4){}`，因为会先执行`==`,所以转换为`if(true || 4){}`,这样的比较会报错。

`case`实际上是在`C#`中定义的标签。

const int num = 1; -- 表示创建一个常量，这个值是不可以改变的。
string.ToLower() -- 会把字符转换为小写；

对于计算利息这个实例，如果使用`if`进行判断，则只会被执行一次，如果要重复执行，直到满足条件后，这就需要借用循环来实现，所以这次使用`while`，

对于`C#`来说是有块级作用域的，所以对于`for`循环，如果是在循环内部初始化的变量，在循环外部如果去访问就会报错。

```c#
 for (int i = 1; i < 10; i++)
            {
                Console.WriteLine("The number is {0}", i);
            }
            Console.WriteLine("{0}",i);	// 报错，i不存在
            Console.ReadKey();
```

---

### 第五章 变量的更多内容

类型的转换分为： 显示转换和隐式转换
类型转换常见于数值转换中，
小范围的数值可以 -- 隐式转换 -- 为大范围的数值，

```c#
short num2 = 281;
int num3;
num3 = num2;	
```

```c#
short num2 = 281;
byte num3;
num3 = num2;	// 报错，不能进行隐式转换 需要进行显示转换
```
如果是大范围的数值 进行隐式转换 为小范围的数值，这样就会出错。此时就需要进行 -- 显示转换

**任何类型 A，只要其取值范围完全包含在类型B 的取值范围内，就可以隐式转换为类型B。**

```c#
short num2 = 281;
byte num3;
num3 = (byte)num2;	
```

但是，进行显示转换时候，尤其是大数值转换为小数值时候容易出现数值丢失，尤其是超过了小数值极限时候

强制转换只能在某些情况下是可行的，彼此之间如果没有什么关系的类型是不能进行强制转换的。

在强制转换时候可以使用关键字 -- `checked, unchecked`进行溢出的检查与否。

vs默认是关闭对于溢出的检查的，可以手动开启，右击解决方案资源管理器，选择‘属性’，然后单击‘打开
’面板，选择高级，勾选多选框，溢出。

orientation 发现， 方向
enum 枚举

---

复杂的变量类型 -- 枚举， 结构， 数组

枚举，感觉像是自定义类型，然后创建自定义类型的变量，并赋值自定义类型的属性值。
定义自定义类型需要使用变量enum，
对于数值，即便自定义类型的数值也是`byte`, 但是需要先通过`enum`来声明一个自定义变量，然后定义自定义变量的类型，
enum orientation: byte
{
  north = 1,
  south = 2,
  east = 3,
  west = 4
}
这个自定义变量声明在命名空间内部。
枚举的基本类型可以是：byte, sbyte, short, ushort, int, uint, long, ulong;也就是说，都是数值类型的。

---

对于结构，有点类似于js的构造函数，或者说是函数，使用关键字`struct`进行结构类型声明；
结构类型的声明也是命名空间的直接子元素。

---

### 数组

对于数组类型，和js的区别还是挺大的。首先数值需要声明类型，其次数组的值是写在对象中的。
string[] friends = {"wmsj100", "robiet", "taxi"};
而且获取数组的长度时候，使用的是`Length`,而不是`length`，首字母大写；

对于数组的遍历可以使用`for`和`foreach`,前者遍历时候是可以写入的，而后者是以只读的方式遍历数组。后者的代码会比较简洁。

#### 多维数组

对于多维数组的访问方式也和`js`不同，`js`中是类似这样`nums[1][2]`，而`c#`中是`nums[1,2]`，感觉`c#`的优雅一些。

对于多维数组的声明比较麻烦，声明时候，`[,]`内部有一个逗号来区分。
`int [，] nums = {{1, 2, 3}, {2,3,4}, {3,4,5}}`
就是数组内部的成员数量必须是一致的，个数相同。
对于多维数组的遍历可以使用`foreach`，但是遍历的结果是一次遍历每一个子数组的值，并且依次显示。

#### 锯齿数组

```c#
 int[][] nums = {
                                new [] {1,2,3,4},
                                new [] {11,22},
                                new [] {43, 55, 72}
                            };
            foreach (int[] key in nums)
            {
                foreach (int val in key)
                {
                    Console.WriteLine(val);
                }
            }
            Console.ReadKey();
```
上面是一个完整的锯齿数组的声明，首先声明的方式不同，`int[][] nums `， 然后定义的时候也不同`new [] {}`,
区别最大的应该是遍历时候的`foreach`的嵌套，第一层使用`int[]`,第二层使用`int`，然后对第一层的`key`进行遍历。

矩形数组通常比较简单，但是锯齿数组的使用也不会影响效率

---

### 字符串的处理

字符串可以通过下标进行单个字符的访问。`str[1]`;
`string`类型可以看作是`char`变量的只读数组。
也可以把字符串拆分为数组进行`foreach`遍历，通过`ToCharArray`方法来实现这个操作。但是声明这个数组使用类型是`char[]`,这一点需要注意。
`char[] myChars = myStr.ToCharArray();`
当然了，通过`foreach`循环时候，的变量声明也是`char`类型来实现的。
`foreach(char key in names){}`;

- `ToCharArray` -- 可以把字符串全部拆分为单个字符的数组。但是这个数组是无法直接输出的，否则就会显示类似`js`中的`。systen array[]` 需要通过`for`， `foreach`进行分别遍历来显示。
这个方法没有参数。

可以直接通过`Length`来获取字符串的长度。

字符串和`js`中是一样的，只能读取，但不能写入。

- `str.ToLower()` -- 转换为小写
- `str.Trim()` -- 去掉字符串前面和后面的空格
`trim`还可以添加参数，参数为`char[]`的数组形式，表示从字符串的开头和结尾删除指定的字符。
`char[] trimChar = {' ', 'e', 's'};`
`str.Trim(trimChar);` 

`c#`中的双引号和单引号是有很大区别的，使用双引号表示字符"e" -- `string`，但是使用单引号，`e' 却不表示字符串。

还可以使用`TrimStart(char), TrimEnd(char)`，就是在字符串的头部和尾部删除指定字符，这个方法必须使用`char`声明的数组。

- `PadLeft, PadRight` -- 表示通过在字符串的左边或者是右边添加空格来使字符串达到指定长度。多用于对齐字符串。这个方法还可以添加参数，和`js`的`join`和类似，
`string.PadLeft(10, '-')`;

- `Split` -- 按照指定的字符把字符串分割为数组，这个和`js`的`split`基本一样。
`Split`接受的参数（分隔符）不能是用双引号包裹的字符，必须是单引号包裹。
`str.Split(' ')`

- `Join` -- 按照指定的字符把数组连接起来。但是这个方法只能在`string`调用，不能通过数组进行调用。
`string.Join(" ", myArr);` 连接符必须是通过双引号包裹的（空格）；

当使用`vs`的智能提示功能时候，因为会阻挡后面的代码，所以此时可以按下`Ctrl`，稍等一会儿，智能提示面板就会变得透明。松开`Ctrl`面板又恢复正常。

---

对于声明的变量要进行赋值，否则会提示错误

---

### 第六章 函数

函数必须使用俩个关键字 `static void`,  `static` 与面向对象有关系，`void`表示函数没有返回值。而且函数是在`program`下的直接子元素，函数的首字母大写。

return会立即终止函数。

如果函数声明时候没有明确的声明`void`,那么函数就必须返回一个值，也就是说，函数内部必须要有`return`，否则就会报错。
而且函数的返回值和函数定义时候类型声明必须匹配。

`static string getNum(){}`，

如果要定义参数数组，也就是说，不定数量的参数，需要使用关键字`params`。
如果使用`params`，则参数数组必须在参数的末尾，如果有其他的比如参数引用，必须放在前面。
`static int nums(ref int index, params int[] nums)`；

对于通过直接给函数传入参数的方法，不会修改值本身，函数运行完成只会，值还是之前的。如果想要改变值，就需要使用-- 引用参数 -- 方法。

- `ref` -- 使用引用参数时候，函数定义和函数调用都必须使用`ref`方式，

```c#
static int nums3(ref int val)
        {
            return val *= 2;
        }
/ ... /
nums3(ref myInt1);
```
使用引用变量有俩个条件：
- 在函数调用之前，引用变量必须已经声明并且赋值。
- 引用变量必须不是常量，即不能是通过`const`声明的变量。

- `out` -- 输出变量 -- 它基本和引用类型相同，但是区别还是挺大的：
- 在函数定义和调用时候都需要使用`out`，
- 要`out`的变量只需要声明即可，
- 在函数内部需要重新对`out`的变量进行赋值，因为变量通过`out`方式引入函数内部时候，值就已经丢失。

#### 变量的作用域

`c#`是块级作用域，通过大括弧来分割的，在块级作用域内部声明的变量，外部是无法访问到。包括`if` `for`等作用域。

局部变量会屏蔽同名全局变量，所以就必须使用`Program.myStr1`。如果局部变量和全局变量不同名，就可以省去`Program`。

在声明变量时候如果赋值过程在后面，那么在第一次声明的位置就最好直接进行赋值操作。如赋值空字符串。

最佳实践是，最好在声明变量的过程中就对其进行赋值操作，然后再在代码块中使用它们，但是对于循环是例外，循环一般在循环的过程中声明和赋值变量`i`。这样循环结束后就无法访问计数器`i`，因为很少需要在外面访问计数器。

#### 参数和返回值与全局数据

通过使用全局变量可以达到引用变量和输出变量的效果，但是因为全局变量的值可以被其他函数修改， 这会导致无法预料的问题。就像`js`中一样，尽可能的少用全局变量。

常常希望一个函数只有一个目的。只在合适的时候使用全局变量。

#### Main函数

`Main`函数是`c#`引用程序的入口点，执行这个函数就是执行应用程序，在`Main`函数执行完毕时，执行过程也就结束了。

#### 结构函数

这个有点像`js`中的构造函数了，就是先定义一个函数，然后通过留出的接口填充数据，并且通过方法进行
调用。
但是函数的声明是通过`struct`关键字，接口是通过关键字`public`。只要是`public`声明的变量，都可以在函数被调用时候使用。
而且这个方法创建的函数的最大的区别是没有`（）`,直接就是跟着`{}`，里面是内容。下面是一个例子。
因为这也算是函数，所以声明在`Program`下面。

```c#
struct Mode
        {
            public string name;
            public byte age;
            public string show()
            {
                return name + ": " + age + ";";
            }
        }
/.../
Mode name1;
            name1.name = "wmsj100";
            name1.age = 28;
            Console.WriteLine(name1.show());
```

#### 函数的重载

函数的签名包含函数的名称及其参数。用相同的签名定义俩个函数是错误的。

其实函数重载这个应该是比较熟悉了，因为老说`js`没有重载，原来重载是这个样子，也挺简单的，就是根据输入的参数和名称来判断函数，返回值不算。所以一个函数就可以写入多个类型的参数，比如`int, double, type, ...`。范例如下：

```c#
static int fn1(ref int val)
        {
            return val *= 2;
        }

        static double fn1(ref double val)
        {
            return val *= 2;
        }
```

#### 事件代理

看到这个名称就想到了`js`中的事件代理，但是它们的区别还是挺大的，我暂时就没有发现什么共同点，模式也很陌生。

首先是通过关键字`delegate`声明一个事件代理
然后在后面定义俩个函数，算了，直接上码；

```c#
delegate double ProcessDelegate(double param1, double param2);
        static double Multiply(double param1, double param2)
        {
            return param1 * param2;
        }
        static double Divide(double param1, double param2)
        {
            return param1 / param2;
        }
        static void Main(string[] args)
        {
            ProcessDelegate process;
            Console.WriteLine("Please enter two numbers sepatate by comma");
            string input = Console.ReadLine();
            int commaPos = input.IndexOf(',');
            double param1 = Convert.ToDouble(input.Substring(0, commaPos));
            double param2 = Convert.ToDouble(input.Substring(commaPos + 1, input.Length - commaPos - 1));
            Console.WriteLine("enter M or D");
            input = Console.ReadLine();
            if (input == "M")
            {
                process = new ProcessDelegate(Multiply);
            }
            else
            {
                process = new ProcessDelegate(Divide);
            }
            Console.WriteLine(process(param1, param2));
            Console.ReadKey();
```

这个函数用到了好几个方法，其中`Substring`和`js`的`substr`类似，即显示下标，然后是要获取的字符长度。

---

### 第七章 调试和错误处理

。。。
这一章完全没有头绪，所以先跳过去了。以后碰到了，再回来吧。
---

### 第八章 面向对象编程简介

- 对象 -- 就是`OOP`应用程序的一个组成部件。它封装了部分应用程序，这部分程序可以是一个过程、一些数据、一些更抽象的实体。
- 对象是从类型中创建的，可以使用类的定义实例化对象，这表示创建该类的一个实例。类的实例就是一个对象。

- UML -- 统一建模语言 -- 是为应用程序建模而设计的，从组成应用程序的对象，到它们执行的操作，到希望有的用例。

- `myPrinter: Printer` -- 前面是实例，后面是类，中间用一个冒号分割；

- 可以通过属性的字段访问对象中包含的数据，同一个类的不同对象在属性和字段中存储了不同的值。
包含在对象中的不同数据构成了对象的状态。

- 字段和属性都可以键入，所以可以把信息存储在字段和属性中，作为`string`, `int`值等。

- 属性和字段是不同的，属性不提供对数据的直接访问，对象让用户不考虑数据的细节，

- 一般情况下，在访问状态时最好提供属性，而不是字段，这样可以更好的控制各种行为。

使用属性和字段的语法是相同的。
对属性的读写访问可以由对象明确定义。
属性有 - 只读、只写；
字段和属性还有一个属性 -- 可访问性； -- 确定了什么代码可以访问这些成员，它们是可用于所有的代码（公共），还是只能用于类中的代码（私有），或者更复杂的模式。

常见的情况是把字段设置为私有，通过公共属性访问它们。这样，类中的代码就可以直接访问存储在字段中的数据，而公共属性禁止外部用户访问这些数据，以防止它们在其中放置无效的内容。公共成员是类可以访问的成员。

在`UML`中属性和字段没有区别。因为语法相同。如下：

`+Milk : bool` -- 一个典型的属性字段 ，前面的`+`表示可访问性中的公共成员， `-`表示私有成员； 成员名和成员类型之间使用冒号分隔；

2. 方法 -- 表示对象中的函数，用于提供访问对象的功能。与属性和字段一样，方法也可以是公共或私有的。
`+AddSugar(in amout: byte): byte`; -- 最后显示的类型是返回值类型，每个参数都带有`in ,out, inout`之一，表示数据流的方向，后面是参数的类型。

#### 一切皆对象
`<String>.Length/ <String>.ToUpper()` -- 句点字符把对象实例名和属性或方法分隔开来，方法名后面的`()`把方法和属性区分开来。

每个对象都有一个生命周期，有以下三个状态：
- 正在使用 -- 
- 构造阶段 -- 对象最初进行实例化的时期。这个初始化过程称为构造阶段，由构造函数完成。
- 析构阶段 -- 在删除一个对象时，常常需要执行一些清理工作，例如释放内存，这由析构函数完成。

1. 构造函数 -- 对象初始化时候是自动完成的，但是有时候需要执行一些额外的工作，例如需要初始化对象存储的数据。构造函数就是用于初始化数据的函数。

所有的类定义都至少包含一个构造函数，在这些构造函数中可能有一个默认的构造函数，该函数没有参数，与类同名。类定义还可能包含几个带参数的构造函数，称为非默认的构造函数。代码可以使用它们以许多方式实例化对象，例如给存储在对象中的数据提供初始值。

在`c#`中使用`new`关键字来调用构造函数。下面是通过默认的构造函数实例化一个对象。
`CupOfCoffee myCup = new CupOfCoffee();`
还可以用非默认的构造函数来创建对象。
`CupOfCoffee myCup = new CupOfCoffee("Blue Mountain");`

构造函数和字段、属性、方法一样，可以是公共或私有的。在类外部的代码不能使用私有构造函数实例化对象，而必须使用公共构造函数。

一些类没有公共的构造函数，外部代码不可能实例化它们，这些类称为不可创建的类。

- 析构函数 -- `.NET`使用析构函数清理对象。一般情况下不需要提供析构函数的代码，而是由默认的析构函数自动执行。但是在删除对象前需要执行一些重要操作，就应提供特定的析构函数。

#### 静态和实例类成员

属性、方法和字段等成员是对象实例特有的，此外还有静态成员，(共享成员)，拥有静态方法、静态属性、静态字段。静态成员可以在类的实例之间共享，可以将它们看作是类的全局对象。

静态属性和静态字段可以访问独立于任何实例的数据，静态方法可以执行与对象类型相关，但与对象实例无关的命令，使用静态成员时，甚至不需要实例化对象。

`Console.WriteLine()` `Convert.ToString()` 这些都是静态的。不需要实例化。

类的静态成员用下划线表示

- 静态构造函数

使用类中的静态成员时，需要预先初始化这些成员，静态构造函数用于初始化任务。一个类只能有一个静态构造函数，该函数没有访问修饰符，没有参数。静态构造函数不能直接调用。只能在下列情况执行：
- 创建包含静态构造函数的类实例时
- 访问包含静态构造函数的类的静态成员时
在上面俩中情况下，会先调用静态构造函数，之后实例化类或访问静态成员。无论创建了多少个静态类实例，其静态构造函数都只会调用一次。
通常将非静态构造函数称为 -- 实例构造函数

- 静态类 -- 只能包含静态成员，不需要实例构造函数。不能实例化对象。

---

### OOP技术

对象的特性包括： 接口、继承、多态性、对象之间的关系、运算符重载、事件、引用类型和值类型

#### 接口 

- 接口时把公共实例(非静态)方法和属性组合起来，以封装特定功能的一个集合。一旦定义了接口就可以在类中实现它。这样，类就可以支持接口所指定的所有属性和成员。

接口不能单独存在，不能像实例化一个类那样实例化一个接口。接口不能包含实现其成员的任何代码，而只能定义成员本身。实现过程必须在实现接口的类中完成。

接口的名称一般用大写字母`I`开头。

一个类可以有多个接口，多个类也可以共用一个接口。

- IDisposable --  可删除对象接口，必须实现`Dispose()`方法。

#### 继承
继承是OOP最重要的特性之一，任何类都可以从另一个类中继承，这就是说这个类拥有它继承的类的所有被继承的类称为父类，c#中的对象仅能直接派生于一个基类，当然基类也可以有自己的基类。

继承性可以从一个较一般的基类扩展或创建更多的特性类。

派生类不能访问基类的私有成员，但是可以访问基类的共有成员。

- `protected` -- 只有派生类才可以访问protected成员，对于外部代码来说，这个可访问性和私有成员是一样的。外部代码不能访问`private`和`protected`成员。

除了定义成员的保护级别外，可以定义成员的继承行为，
基类的成员可以是虚拟的，成员可以由继承它的类重写。派生类可以提供成员的其他实现代码。这种实现代码不会删除原来的代码，仍可以在类中访问原来的代码，但外部代码不能访问它们。 他妈的，说的这么罗嗦就是说可以在派生类中定义基类的同名方法，以此来覆盖基类方法。

基类还可以定义为抽象类，抽象类不能直接实例化，要使用抽象类必须继承这个类。
抽象类可以有抽象成员，这些成员在基类中没有实现代码，这些实现代码必须在派生类中提供。
当然了，抽象基类可以提供成员的实现代码，不能实例化抽象类并不意味着不能在抽象类中封装功能。

类可以时密封的，密封的类不能用作基类，所以没有派生类。

在`c#`中所有的对象都有一个共同的基类`object`，他是`Systen.Objtct`类的别名。

接口也可以继承自其他接口，与类不同的是，接口可以继承多个基接口。

### 多态性

可以把某个派生类型的变量赋值给基本类型的变量；
`Animal myAnimal = myCow;`
这样就可以通过基本类型的变量调用基类的方法；
`myAnimal.EatFood()`;
结果是调用派生类中的`EatFood()`的实现代码。但是不能通过这个变量调用派生类上定义的方法。
但是，可以把基本类型的变量转换为派生类型变量，调用派生类型的方法。
`Cow myNewCow = (Cow)myAnimal;`
`myNewCow.Moo();`

如果原始变量的类型不是`Cow`或派生于`Cow`的类型，这个强制类型转换就会引发一个异常。

在`c#`中，所有的类都派生于同一个类`object`,它是继承层次结构中的根。所以，可以把所有的对象看作是`object`类的实例。

#### 接口的多态性

尽管接口不能像对象那样实例化，但可以建立接口类型的变量。然后就可以在支持该接口的对象上，使用这个变量访问该接口提供的方法和属性。


可以把方法不放到基类上面，而是放到接口变量`IConsume`中，`Cow`和`Chicken`类也支持这个接口，唯一的区别是它们必须提供`EatFood()`方法的实现代码，因为接口不包含实现代码。

```c#
Cow myCow = new Cow();
Chicken myChicken = new Chicken();
IConsume consumeInterface;
consumeInterface = myCow;
consumeInterface.EatFood();
consumeInterface = myChicken;
consumeInterface.EatFood();
```

这就提供了以相同的方式访问多个对象的简单方式，且不依赖于一个公共的基类，例如这个接口可以由派生于`Vegetable`的`VenusFlyTrap`类实现，而不是由`Animal`实现：

```c#
VenusFlyTrap myVenusFlyTrap = new VenusFlyTrap();
IConsume consumeInterface;
consumeInterfmyCow;;
```

在这段代码中，调用 consumeInterface.EatFood()的结果是调用 Cow、Chicken 或 VenusFlyTrap
类的EatFood()方法，这取决于哪个实例被赋予了接口类型的变量。

---

### 对象之间的关系
继承是对象之间的一种简单关系，可以让派生类完整的获得基类的特性，而派生类也可以访问基类内部的一些工作代码(通过受保护成员)。

- 保含关系： -- 一个类包含另一个类。
- 集合关系： 一个类用作另一个类的多个实例的容器。这类似于对象数组，但集合有其他功能，包括索引、排序和重新设置大小等。

---

#### 事件

对象可以激活事件，作为它们处理的一部分。
使用事件可以创建事件驱动的应用程序，这一部分是我感兴趣的。

#### 引用类型和值类型

在`c#`中，数据根据变量的类型以俩种方式中的一种存储在一个变量中。变量的类型就分：值类型和引用类型，这个`js`中的是一样的。

- 值类型： 在内存的一个地方存储它们自己的它们的内容
- 引用类型： 存储指向内存中其他某个位置(称为堆)的引用，而在另一个位置存储内容。

他俩的区别是：值类型总是包含一个值，而引用类型可以是`null`。

只有`string`和`object`简单类型是引用类型。数组也是隐式的引用类型。我们创建的每一个类都是引用类型。

---

### windows应用程序中的OOP

windows应用程序非常依赖OOP技术，	
`Controls` -- 这个属性是一个对象，是窗体上所有控件的组合，通过它的`add`方法把新按钮添加到窗体上。

对于这个按钮事件，其实首先就是当点击按钮时候修改该按钮的文字，并且创建一个新按钮，设置新按钮的文字，然后给新按钮添加一个点击事件，这个事件就是改变新按钮的文字，最后通过`Controls.Add(new Btn)`命令把新按上码到窗体上面。

```c#
private void button2_Click(object sender, EventArgs e)
        {
            ((Button)sender).Text = "Click Me";
            Button newBtn = new Button();
            newBtn.Text = "new Btn";
            newBtn.Click += newBtn_Click;
            Controls.Add(newBtn);
        }

        void newBtn_Click(object sender, EventArgs e)
        {
            ((Button)sender).Text = "Hello";
        }
```

这一章很纠结，因为都是理论性质的内容，但是到现在也算是结束了，开始真正的实例。

---

### 第九章 定义类

`c#`中使用`class`关键字来定义类；

默认的`class`只能内部访问，如果是公共类，则需要添加关键字`public`，
- abstract -- 抽象类，不能实例化，只能继承
- sealed -- 密封类 ， 不能继承，不能供派生之用，只能实例化

`public abstract class MyClass{}`
`public sealed class MyClass{}`

还可以在类中指定继承，在类名后面加冒号，其后是继承名
`public class MyClass: MyBas{}`

`c#`的类定义中，只能有一个基类，
编译器不允许派生类的可访问性高于基类，也就是说，内部类可以继承于一个基类，但是基类不能继承于一个内部类。

如果没有使用基类，则被定义的类就只继承于基类`System.Object`(object);

指定基类和接口的正确方式是，类名称后面的冒号紧跟基类名， 然后是一个逗号，然后是支持的接口。
`public class MyClass: MyBase, IMyInterface{}`

可以指定多个接口，
`public class MyClass: MyBase, IMyInterface, IMySecondInterface{}`

- interface --  声明接口使用的关键字， 接口默认为内部接口，可以使用关键字`public`，转换为公共接口。

接口的继承如下：
`public interface IMyInterface: IMyBaseInterface, IMyBaseInterface2{}`;

项目初始化时候的类`Program`处理的`Main()`方法是应用程序的入口点。

typeof -- c#运算符，可以把类名转换为`System.Type对象`

---

### 构造函数和析构函数

构造函数和析构函数通常不需要定义，因为编译器会自动添加它们。
这俩个函数在类的声明内部添加，
析构函数使用前缀`~`来声明

```c#
 public abstract class MyBase
    {
        public MyBase()
        { 
        }
        public MyBase(int myInt)
        { 
        }
        ~MyBase()
        { 
        }
    }
```

当调用自定义的析构函数后还会隐式的调用基类的析构函数
`public MyDivideClass(int i, int j): base(i){}` -- 其中`base`关键字指定`.NET`实例化过程中使用基类中有指定参数的构造函数。

`public MyDivideClass(): base(5){}` -- 

除了`base`关键字外，还可以将另一个关键字`this`用作构造函数初始化器。用于指定当前类使用非默认的构造函数：

```c#
public class MyDerivedClass : MyBaseClass
{
public MyDerivedClass() : this(5, 6)
{
}
...
public MyDerivedClass(int i, int j) : base(i)
{
}
}
```

在定义构造函数时候，不要创建无限循环。

```c#
public class MyBaseClass
    {
        public MyBaseClass(): this(5)
        { 
        }
        public MyBaseClass(int i): this()
        { 
        }
    }
```

上面这段代码就是一个无限循环，当尝试实例化时候就会提示异常。


把类放在单独的文件中，可以更轻松的管理类，单独放置的类的命名空间和程序页面的命名空间是相同的。
这样创建的类没有添加构造函数，编译器在执行时候会自动添加一个默认的构造函数。

---

#### 类库 

类可以放置在项目的不同文件中，还可以把它们放到不同的项目中。如果一个项目什么都不包含，除了类（以及其他相关的类型定义），但没有入口点。这个项目就称为类库。

类库项目编译为`.dll`程序集。在其他项目中添加对类库项目的引用，就可以访问它的内容。这将扩展对象提供的封装性。因为类库可以进行修改和更新。

对于类库内部的构造函数不需要使用`void`，即便函数没有返回值。

当调用类库时候，首先需要在资源管理器中的‘引入’右键添加刚刚创建的类库文件，然后通过`using`来声明类库，

---

### 接口和抽象类

接口和抽象类都可以是派生类继承的成员，他俩都不能实例化，但可以声明这些类型的变量。然后就可以使用多态性把继承这俩种类型的对象指定给它们的变量。接着通过这些变量来使用这些类型的成员。

接口和抽象类的区别如下：
- 派生类只能继承一个基类，即只能直接继承一个抽象类(但可以用一个继承链包含多个抽象类)
- 类可以使用任意多个接口，
- 抽象类可以拥有抽象成员（没有代码体，且必须在派生类中实现，否则派生类本身也必须是抽象的）和非抽象成员（它们拥有代码体，也可以是虚拟的，这样就可以在派生类中重写）。
- 接口成员必须都在使用接口的类上实现--它们没有代码体，另外，按照定义，接口成员是公共的，因为它们倾向于在外部使用。
- 抽象类成员可以是私有的（只要不是抽象的）、受保护的、内部的或受保护的内部成员。
- 接口不能包含-- 字段， 构造函数， 析构函数， 静态成员，常量。
- 抽象类主要用作对象系列的基类，共享某些主要特性，
- 接口则主要用于类，这些类在基础水平上有所不同。

---

### 结构类型

结构和类非常相似，但结构是值类型，而类是引用类型。

```c#
namespace ConsoleApplication2
{
    public class MyClass
    {
        public int val;
    }

    public struct MyStruct
    {
        public int val;
    }
    class Program
    {
        static void Main(string[] args)
        {
            MyClass myObj1 = new MyClass();
            MyClass myObj2 = myObj1;
            myObj1.val = 10;
            myObj2.val = 20;
            MyStruct myObj3 = new MyStruct();
            MyStruct myObj4 = myObj3;
            myObj3.val = 30;
            myObj4.val = 40;
            Console.WriteLine("myObj1 =>{0}\nmyObj2 => {1}\nmyObj3 => {2}\nmyObj4 => {3}", myObj1.val, myObj2.val, myObj3.val, myObj4.val);
            Console.ReadKey();
        }
    }
}
```

上面的操作过程如下： 
-  声明类型的变量；
-  在这个变量中创建该类型的新实例；
- 声明类型的第二个变量；
- 把第一个变量赋值给第二个变量；
- 在第一个变量的实例中给`val`字段赋一个值
- 在第二个变量的实例中，给`val`字段赋一个值
- 显示俩个变量的`val`字段值 

---

### 第十章 定义类成员

