---
title: 函数
date: 2016-08-15
tags: [C#]
categories: Language
---

函数 -- 一段被封装起来的能实现一定功能的代码。

函数要定义在主函数外面，和主函数并列。

`static` -- 说明函数是一个静态函数，非静态函数需要实例化后才可以使用，静态函数则可以直接使用。

复杂的任务一般要分解为多个小任务，每个小任务由一个函数实现。

`c#`程序以主函数`Main()`为入口，逐条执行主函数的代码。
执行完主函数的所有代码后，整个程序也就终止了。

`.NET`函数命名方式采用`帕斯卡式`命名方式，首字母大写。

函数通过`return`语句返回结果。碰到`return`就立即返回主调函数，其后的语句将不会被执行。

返回值的类型要和函数定义时候的类型一致。

‘行参’ -- 函数定义时候的参数，需要指定参数的类型。
‘实参’ -- 函数调用时候的参数，必须和行参类型相同。

`ref` -- 引用类型的关键字，

因为对于简单数值的引用是‘值’的引用，所以通过参数的调用的更改不会反应到实参上面，所以需要通过`ref`引用来把‘简单类型’的值转换为‘引用类型’的值。

但是使用`ref`时候，函数定义时候就需要声明参数为引用类型，而且函数调用时候的参数引入也需要声明`ref`。

```c#
static void change(ref int x, ref int y)
        {
            int proxy = x;
            x = y;
            y = proxy;
        }
...
int a = 10, b = 20;
change(ref a,ref b);
Console.WriteLine(a + " " + b );
```

---

一个函数可能产生多个有价值的计算结果，而使用`return`语句只能返回一个数据。使用`ref`能改变实参的值，天然的能将计算结果返回到主调函数中。
`out`型和`ref`的使用方式几乎一样，二者之间只有一个区别：
- `ref`型参数传入函数前必须赋值
- `out`型参数传入前不需要赋值，即便赋值也会被忽略。
所以`out`型参数只能从函数返回结果，不能用来向函数传递数据。在函数结束前，必须为`out`型参数赋值。

```c#
 static double GetArea(int r, out double c)
        {
            c = 2 * Math.PI * r;
            double s = Math.PI * r * r;
            return s;
        }
...
double c, s;
s = GetArea(12, out c);
Console.WriteLine("周长" + c + "\n" + "面积" + s);
```

对于上面的函数，因为计算圆面积时候还想获得圆的周长，但是`return`只能返回一个值，所以此时就用到了`out`，因为值是在函数运算过程中得到的，所以不需要在引入前赋值。而且通过`out`方法会把这个值保存下来。当然了，这个使用`ref`方法也是可以的，只是需要在声明的时候先随便赋值。

---

调用函数时，实参和行参应该匹配，如果不匹配，会自动进行隐式转换，如果转换不成功，会报错。

- 可选参数 -- 就是函数调用时候，如果可选参数没有输入值，则使用默认值，也就是说可选参数必须赋值。

```c#
static double GetVolume(double r, out double c, double pi = 3.14)
        {
            c = 2 * pi * r;
            double s = pi * r * r;
            return s;
        }
...
double c = 0, s;
s = GetVolume(12, out c);
Console.WriteLine("周长" + c + "\n" + "面积" + s);
```

如果调用函数的时候没有输入`pi`的值，则使用默认值`3.14`，否则使用输入值。

---


函数反复调用本身的行为称为递归调用。

递推公式包含俩个要素：递推关系和初始值。

---

### 变量的作用域

在函数内部定义的变量，只在该函数内部有效，它的作用域从定义的地方开始，知道函数结束为止。如果在函数内部变量的定义之前调用，会报错。

```c#
static void fn()
        {
            Console.WriteLine(a);   // 报错，局部变量在声明之前无法使用。
            int a = 1;
            Console.WriteLine(a);
        }
```

实际上给变量命名只是方便人们编辑代码，在编译阶段，变量的名字都被转换为数字编码

程序块中的局部变量只在程序块中有效，在外部访问会警告变量不存在。

```c#
for (int i = 0; i < 3; i++)
    {
        int s = 1;
        Console.WriteLine(s);
    }
    Console.WriteLine(s); // 变量不存在
```