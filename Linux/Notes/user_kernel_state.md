---
title: 用户态和内核态
date: 2020-03-27 13:42:12
modify: 
tags: [Notes]
categories: Linux
author: wmsj100
email: wmsj100@hotmail.com
---

# 用户态和内核态

## 概要

- 内核态: cpu可以访问内存的所有数据,包括外围设备,例如硬盘和网卡,cpu也可以将自己从一个程序切换到另一个程序.
- 用户态: 只能受限的访问内存,且不允许访问外围设备,占用cpu的能力被剥夺,cpu资源可以被其他程序获取.

## 为什么要有内核态和用户态

- 由于需要限制不同程序之间的访问能力,防止他们获取被的程序的内存数据,或者获取外围设备的数据并发送到网络,cpu划分出俩个权限等级

## 用户态和内核态切换

- 所有用户程序都运行在用户态,但有时候程序需要做一些内核态的事情,例如从硬盘读取数据,或者从键盘获取输入,而唯一可以做这些事情的就是操作系统,所以此时程序就需要向操作系统请求以程序的名义来执行这些操作.
- 这时需要一个这样的机制:用户态程序切换到内核态,但是不能控制在内核态中执行的命令
- 这种机制叫做系统调用,在cpu中的实现称之为陷阱指令.
- 他们的工作流程如下:
	- 用户态程序将一些数据放在寄存器中,或者使用参数创建一个堆栈,以此表明需要操作系统提供的服务.
	- 用户态程序执行陷阱指令
	- cpu切换到内核态,并跳到位于内存指定位置的指令,这些指令是操作系统的一部分,他们具有内存保护,不可被用户态程序访问.
	- 这些指令称之为陷阱或者系统调用处理器,他们会读取程序放入内存的数据参数,并执行程序请求的服务.
	- 系统调用完成后,操作系统会重置cpu为用户态并返回系统调用的结果
- 当一个任务(进程)执行系统调用而陷入内核代码中执行时,我们就称进程处于内核运行态(或简称为内核态).此时处理器处于特权级最高的(0级)内核代码中执行.
- 当进程处于内核态时,执行的内核代码会使用当前进程的内核栈.
- 那个进程都有自己的内核栈,
- 当进程在执行用户自己的代码时,则称其处于用户运行态(用户态).即处理器此时处于特权级最低的(3级)用户代码中执行.
- 当正在执行用户程序而突然被中断程序中断时,此时用户程序可以象征性的称为处于进程的内核态.
- 因为中断处理程序将使用当前的内核栈.这与处于内核态的进程状态有些类似.
- 内核态和用户态是操作系统的俩种运行级别,跟Intel CPU没有必然的联系,
- Linux使用了Ring3作为用户态,Ring0作为内核态.
- Ring3不能访问Ring0的地址空间,包括代码和数据,
- Linux进程的4G地址空间,3G~4G部分是共享的,是内核态的地址空间,这里存放整个内核的代码和所有内核模块,以及内核所维护的数据.
- 用户运行一个程序,该程序所创建的进程开始是处于用户态的,如果要执行文件操作,网络数据发送等操作,必须要通过write,send等系统调用,这些系统调用会调用内核中的代码来完成操作,这时,必须切换到Ring0,然后进入3G~4G中的内核地址空间去执行这些代码完成操作,完成后,会切换会Ring3,回到用户态.
- 这样用户态程序就不能随意操作内核地址空间,具有一定的安全保护作用.
- 至于说保护模式,是说通过内存页表操作等机制,保证进程间的地址空间不会互相冲突,一个进程的操作不会影响到另一个进程的地址空间中的数据.

## 参考

- [用户态和内核态](https://blog.csdn.net/youngyoungla/article/details/53106671)
