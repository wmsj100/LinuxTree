---
title: 数值转换
date: 2016-04-28
tags: [数值,JavaScript]
categories: Dynamic
---

# 数值转换

有 3 个函数可以把非数值转换为数值： Number() 、 parseInt() 和 parseFloat() 。第一个函数，即转型函数 Number() 可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这 3个
函数对于同样的输入会有返回不同的结果。

## number()

Number() 函数的转换规则如下。

  如果是 Boolean 值， true 和 false 将分别被转换为 1 和 0。
  如果是数字值，只是简单的传入和返回。
  如果是 null 值，返回 0。
  如果是 undefined ，返回 NaN 。
  如果是字符串，遵循下列规则：
  如果字符串中只包含数字（包括前面带正号或负号的情况），则将其转换为十进制数值，即 "1"会变成 1， "123" 会变成 123，而 "011" 会变成 11（注意：前导的零被忽略了）；
  如果字符串中包含有效的浮点格式，如 "1.1" ，则将其转换为对应的浮点数值（同样，也会忽略前导零）；
  如果字符串中包含有效的十六进制格式，例如 "0xf" ，则将其转换为相同大小的十进制整数值；
  如果字符串是空的（不包含任何字符），则将其转换为 0；
  如果字符串中包含除上述格式之外的字符，则将其转换为 NaN 。
  如果是对象，则调用对象的 valueOf() 方法，然后依照前面的规则转换返回的值。如果转换的结果是 NaN ，则调用对象的 toString() 方法，然后再次依照前面的规则转换返回的字符串值。
根据这么多的规则使用 Number() 把各种数据类型转换为数值确实有点复杂。下面还是给出几个具体的例子吧

```javascript
var num1 = Number("Hello world!"); //NaN
var num2 = Number(""); //0
var num3 = Number("000011"); //11
var num4 = Number(true); //1
```

一元加操作符的操作与 Number() 函数相同。

由于 Number() 函数在转换字符串时比较复杂而且不够合理，因此在处理整数的时候更常用的是parseInt() 函数。 parseInt() 函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号， parseInt()就会返回 NaN ；也就是说，用 parseInt() 转换空字符串会返回 NaN （ Number() 对空字符返回 0）。如果第一个字符是数字字符， parseInt() 会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如， "1234blue" 会被转换为 1234，因为 "blue" 会被完全忽略。类似地， "22.5"会被转换为 22，因为小数点并不是有效的数字字符。
  	如果字符串中的第一个字符是数字字符， parseInt() 也能够识别出各种整数格式（即前面讨论的十进制、八进制和十六进制数）。也就是说，如果字符串以 "0x" 开头且后跟数字字符，就会将其当作一
个十六进制整数；如果字符串以 "0" 开头且后跟数字字符，则会将其当作一个八进制数来解析。
为了更好地理解 parseInt() 函数的转换规则，下面给出一些例子：

```javascript
var num1 = parseInt("1234blue"); // 1234
var num2 = parseInt(""); // NaN
var num3 = parseInt("0xA"); // 10（十六进制数）
var num4 = parseInt(22.5); // 22
var num5 = parseInt("070"); // 56（八进制数）
var num6 = parseInt("70"); // 70（十进制数）
var num7 = parseInt("0xf"); // 15（十六进制数）
```

在 ECMAScript 3 JavaScript 引擎中， "070" 被当成八进制字面量，因此转换后的值是十进制的 56。而在 ECMAScript 5 JavaScript 引擎中， parseInt() 已经不具有解析八进制值的能力，因此前导的零会
被认为无效，从而将这个值当成 "70" ，结果就得到十进制的 70。在 ECMAScript 5 中，即使是在非严格模式下也会如此。
为了消除在使用 parseInt() 函数时可能导致的上述困惑，可以为这个函数提供第二个参数：转换时使用的基数（即多少进制）。如果知道要解析的值是十六进制格式的字符串，那么指定基数 16 作为第二个参数，可以保证得到正确的结果，例如：

```javascript
var num = parseInt("0xAF", 16); //175
实际上，如果指定了 16 作为第二个参数，字符串可以不带前面的 "0x" ，如下所示：
var num1 = parseInt("AF", 16); //175
var num2 = parseInt("AF"); //NaN
```

这个例子中的第一个转换成功了，而第二个则失败了。差别在于第一个转换传入了基数，明确告诉parseInt() 要解析一个十六进制格式的字符串；而第二个转换发现第一个字符不是数字字符，因此就
自动终止了。指定基数会影响到转换的输出结果。例如：
```
var num1 = parseInt("10", 2); //2 （按二进制解析）
var num2 = parseInt("10", 8); //8 （按八进制解析）
var num3 = parseInt("10", 10); //10 （按十进制解析）
var num4 = parseInt("10", 16); //16 （按十六进制解析）
```
NumberExample07.htm不指定基数意味着让 parseInt() 决定如何解析输入的字符串，因此为了避免错误的解析，我们建议无论在什么情况下都明确指定基数。多数情况下，我们要解析的都是十进制数值，因此始终将 10 作为第二个参数是非常必要的。

### parseFloat()

​	与 parseInt() 函数类似， parseFloat() 也是从第一个字符（位置 0）开始解析每个字符。而且也是一直解析到字符串末尾，或者解析到遇见一个无效的浮点数字字符为止。也就是说，字符串中的第一个小数点是有效的，而第二个小数点就是无效的了，因此它后面的字符串将被忽略。举例来说，"22.34.5" 将会被转换为 22.34。

​	除了第一个小数点有效之外， parseFloat() 与 parseInt() 的第二个区别在于它始终都会忽略前导的零。 parseFloat() 可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat() 只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零）， parseFloat() 会返回整数。以下是使用 parseFloat() 转换数值的几个典型示例。

```javascript
var num1 = parseFloat("1234blue"); //1234 （整数）
var num2 = parseFloat("0xA"); //0
var num3 = parseFloat("22.5"); //22.5
var num4 = parseFloat("22.34.5"); //22.34
var num5 = parseFloat("0908.5"); //908.5
var num6 = parseFloat("3.125e7"); //31250000
```



