---
title: 正则表达式——基本语法
date: 2016-3-30 22:35:01
tags: [正则,JavaScript]
categories: Dynamic
---

正则表达式(Regular Expression)是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。
<!-- more -->
## 创建

JavaScript通过内置对象`RegExp`支持正则表达式，有两种方式创建正则表达式对象，如果我们想匹配字符串中`<%xxx%>`两个百分号分割的字符串可以这么写

1. 构造函数

   ```
    var reg=new RegExp('<%[^%>]+%>','g');

   ```

2. 字面量

   ```
    var reg=/<%[^%>]%>/g;

   ```

最后的g代表全局，还有几个修饰符

1. g：global，全文搜索，不添加的话搜索到第一个结果停止搜索
2. i：ingore case，忽略大小写，默认大小写敏感
3. m：multiple lines，多行搜索

## 元字符

正则表达式让人望而却步以一个重要原因就是转义字符太多了，组合非常多，但是正则表达式的元字符（在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符）并不多

```
( [ { \ ^ $ | ) ? * + .

```

并不是每个元字符都有特定的意义，在不同的组合中元字符有不同的意义，分类看一下

| 字符   | 含义                    |
| ---- | --------------------- |
| \t   | 水平制表符                 |
| \r   | 回车符                   |
| \n   | 换行符                   |
| \f   | 换页符                   |
| \cX  | 与`X`对应的控制字符（`Ctrl+X`） |
| \v   | 垂直制表符                 |
| \0   | 空字符                   |

## 字符类

一般情况下正则表达式一个字符（转义字符算一个）对应字符串一个字符，表达式 `ab\t` 的含义是

![image](/file/img/tool/march/0330/101.png)

但是我们可以使用元字符`[]`来构建一个简单的**类**，所谓类是指，符合某些特征的对象，是一个泛指，而不是特指某个字符了，我们可以使用表达式 `[abc]` 把字符a或b或c归为一类，表达式可以匹配这类的字符

![image](/file/img/tool/march/0330/102.png)

### 取反

元字符`[]`组合可以创建一个类，我们还可以使用元字符`^`创建**反向类/负向类**，反向类的意思是不属于XXX类的内容，表达式 `[^abc]` 表示不是字符a或b或c的内容

![image](/file/img/tool/march/0330/103.png)

## 范围类

按照上面的说明如果希望匹配单个数字那么表达式是这样的

```
[0123456789]

```

如果是字母那么。。。，好麻烦，正则表达式还提供了**范围类**，我们可以使用 `x-y`来连接两个字符表示从x到y的任意字符，这是个**闭区间**，也就是说包含x和y本身，这样匹配小写字母就很简单了

```
[a-z]

```

![image](/file/img/tool/march/0330/104.png)

要是想匹配所有字母呢？在[]组成的类内部是可以连写的，我们还可以这样写 `[a-zA-Z]`

![image](/file/img/tool/march/0330/105.png)

## 预定义类

刚才使用正则我们创建了几个类，来表示数字，字母等，但这样写也很是麻烦，正则表达式为我们提供了几个常用的预定义类来匹配常见的字符

| 字符   | 等价类               | 含义               |
| ---- | ----------------- | ---------------- |
| .    | `[^\r\n]`         | 除了回车符和换行符之外的所有字符 |
| \d   | `[0-9]`           | 数字字符             |
| \D   | `[^0-9]`          | 非数字字符            |
| \s   | `[\t\n\x0B\f\r]`  | 空白符              |
| \S   | `[^\t\n\x0B\f\r]` | 非空白符             |
| \w   | `[a-zA-Z_0-9]`    | 单词字符，字母、数字下划线    |
| \W   | `[^a-zA-Z_0-9]`   | 非单词字符            |

有了这些预定义类，写一些正则就很方便了，比如我们希望匹配一个 `ab+数字+任意字符` 的字符串，就可以这样写了 `ab\d.`

![image](/file/img/tool/march/0330/106.png)

## 边界

正则表达式还提供了几个常用的边界匹配字符

| 字符   | 含义     |
| ---- | ------ |
| ^    | 以xxx开头 |
| $    | 以xxx结尾 |
| \b   | 单词边界   |
| \B   | 非单词边界  |

看个不负责任的邮箱正则匹配（切勿模仿，小括号后面会讲到）`\w+@\w+\.(com)$`

![image](/file/img/tool/march/0330/107.png)

## 量词

之前我们介绍的方法都是一一匹配的，如果我们希望匹配一个连续出现20次数字的字符串难道我们需要写成这样

```
\d\d\d\d...

```

为此正则表达式引入了一些量词

| 字符    | 含义              |
| ----- | --------------- |
| ?     | 出现零次或一次（最多出现一次） |
| +     | 出现一次或多次（至少出现一次） |
| *     | 出现零次或多次（任意次）    |
| {n}   | 出现n次            |
| {n,m} | 出现n到m次          |
| {n,}  | 至少出现n次          |
| {,m}  | 最多出现m次          |

看几个使用量词的例子，`\w+\bByron` 匹配 单词＋边界＋Byron

![image](/file/img/tool/march/0330/108.png)

```
(/\w+\bByron).test('Hi Byron'); //true

(/\w+\bByron).test('Welcome Byron'); //true

(/\w+\bByron).test('Byron'); //false

```

`\d+\.\d{1,3}` 匹配三位小数的数字

![image](/file/img/tool/march/0330/109.png)

## 贪婪模式与非贪婪模式

看了上面介绍的量词，也许爱思考的同学会想到关于匹配原则的一些问题，比如`{3,5}`这个量词，要是在句子中出现了十次，那么他是每次匹配三个还是五个，反正3、4、5都满足3～5的条件

量词在默认下是尽可能多的匹配的，也就是大家常说的贪婪模式

```
'123456789'.match(/\d{3,5}/g); //["12345", "6789"]

```

既然有贪婪模式，那么肯定会有非贪婪模式，让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试，做法很简单，在量词后加上`?`即可

```
'123456789'.match(/\d{3,5}?/g); //["123", "456", "789"]

```

## 分组

有时候我们希望使用量词的时候匹配多个字符，而不是像上面例子只是匹配一个，比如希望匹配Byron出现20次的字符串，我们如果写成 Byron{20} 的话匹配的是Byro＋n出现20次

```
Byron{20}

```

![image](/file/img/tool/march/0330/110.png)

怎么把Byron作为一个整体呢？使用`()`就可以达到此目的，我们称为分组

```
(Byron){20}

```

![image](/file/img/tool/march/0330/111.png)

### 或

如果希望匹配Byron或Casper出现20次该怎么办呢？可以使用字符`｜`达到或的功效

```
(Byron|Casper){20}

```

![image](/file/img/tool/march/0330/112.png)

我们看到图中有个`＃1`的东东，那是什么？使用分组的正则表达式会把匹配项也放到分组中，默认就是按数字编号分发的，可以根据编号获得捕获的分组内容，这在一些希望具体操作第几个匹配项的函数中很有用

```
(Byron).(ok)

```

![image](/file/img/tool/march/0330/113.png)

### 分组嵌套

如果有分组嵌套的情况，外面的组的编号靠前

```
((^|%>)[^\t]*)

```

![image](/file/img/tool/march/0330/114.png)

### 忽略分组

有时候我们不希望捕获某些分组，只需要在分组内加上 `?:`就可以了，这并不意味着该分组内容不属于正则表达式，只是不会给这个分组加编号了而已

```
(?:Byron).(ok)

```

![image](/file/img/tool/march/0330/115.png)

其实在C#等语言中分组还可以起名字，不过JavaScript不支持

## 前瞻

| 表达式          | 含义              |
| ------------ | --------------- |
| exp1(?=exp2) | 匹配后面是exp2的exp1  |
| exp1(?!exp2) | 匹配后面不是exp2的exp1 |

有些抽象，看个例子

```
good(?=Byron)

```

![image](/file/img/tool/march/0330/116.png)

```
(/good(?=Byron)/).exec('goodByron123'); //['good']
(/good(?=Byron)/).exec('goodCasper123'); //null
(/bad(?=Byron)/).exec('goodCasper123');//null

```

通过上面例子可以看出 `exp1(?=exp2)` 表达式会匹配`exp1`表达式，但只有其后面内容是exp2的时候才会匹配，也就是两个条件，exp1(?!exp2) 比较类似

```
good(?!Byron)

```

![image](/file/img/tool/march/0330/117.png)

```
(/good(?!Byron)/).exec('goodByron123'); //null
(/good(?!Byron)/).exec('goodCasper123'); //['good']
(/bad(?!Byron)/).exec('goodCasper123');//null

```

## 参考

[司徒正美 JavaScript正则表达式](http://www.cnblogs.com/rubylouvre/archive/2010/03/09/1681222.html)

[Regexper](http://www.regexper.com/)

