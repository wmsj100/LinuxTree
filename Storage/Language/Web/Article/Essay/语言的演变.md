---
title: OO 语言的演变
date: 2016-05-03
tags: [学术]
categories: Article 
---

OO 语言的演变
从时间顺序上来看， C++， Object Pascal， Java， 从 到 到 再到 C#和 Delphi Language， 可以看出编程思想和风格（但并不表示优秀程度和实用性）的演化。 C++是这些语言中出现得最早的，同时它也提供了最好的向后兼容性：几乎全兼容 面向过程编程时代的 C 语言。从市场策略来看，这是非常有远见的举动，C++成功地以

C 语言的后续者出现，但是同时也导致了许多严重的问题。对于这一点，C++的发明者 也并不讳言。C++支持完全的面向对象编程，支持名字空间（Namespace） ，支持嵌套类 型（Nested Type） ，这使得它对大规模程序的开发提供了很好的支持（这也是 C++的 设计目标之一） 。但是，C++ 也保留了全局变量/ 全局函数、Structure 等语法，这在获 得兼容性的同时，牺牲了面向对象的特性（当然，C++的目的并不是纯粹的面向对象， 而是多风格编程） 。另外，C++在 RTTI 上完全无法与后来的几种语言相比。但是，C++ 还 提 供 了 复 杂 的 模 板 和 操 作 符 重 载 机 制 ， 从 而 全 面 支 持 泛 型 编 程 （ Generic Programming） ，这一点目前在这些语言中是独一无二的。总的说来，C++是一门庞大的、 复杂的、博大精深的语言，它在从面向过程编程向面向对象编程的过渡中，最大限度地 保持了向后兼容性，同时也付出了沉重的代价。C++在许多前沿领域，都进行了有益的 探索，这些探索的成果被其它语言所汲取，但也使得 C++的学习门槛过高。 它诞 Object Pascal 是 Anders Hejlsberg 对传统的 Pascal 进行扩展以后发明的语言， 生的背景是面向对象编程思想的流行和 Windows 操作系统的崛起。针对这两个潮流， Object Pascal 做了很多的优化以适应它们。 Object Pascal 支持完全的面向对象编程， 而同时的 Visual Basic 等竞争对手只支 持基于对象的编程（Object-Based Programming） 。 Object Pascal 实现了在委托（Delegate）基础上的事件机制，完整地封装了 Windows 事件处理过程，这使得它对 Windows GUI 程序的开发提供了极好的 支持。 Object Pascal 大幅度地强化了 RTTI 的能力，并在 RTTI 和 PME（Property， Method，Event）模型的基础上实现了自己的开放性的 Component 机制，使得 Delphi 成为一个强大的组件化开发工具。 但是，Object Pascal 的缺点也是相当明显的，这些缺点在长期的使用过程中逐一地 暴露出来了。 Object Pascal 保留了全局变量/全局函数、Record 等语法。和 C++一样，这些特 征提供了向后兼容性，保留了面向过程编程的风格，也许还获得了效率上的好 处。但是，它们同样也破坏了面向对象的特性，很容易造成编程风格上的混乱 （从理论上说，这一点不应引咎于编程语言，但这确实是常见的情况） 。 和 C++不一样，Object Pascal 并不是一开始就是以大规模的程序开发为目标进 行设计的。因此它一直不支持名字空间和嵌套类型等特性，而这些特性对于大 规模的开发是相当重要的。 Object Pascal 的事件机制与 Windows 捆绑得过于紧密， Object Pascal 试图越 当 过 Windows GUI 程序的开发，进入其它的领域时，开发者们或多或少地遇上了 这些问题。

Java 则是一种纯粹的面向对象编程的范例。 “一切都是对象”是 Java 提出的并尽 力予以贯彻的口号。和 C++与 Object Pascal 不同，Java 虽然在语法上尽力保持 C 的风 格，但它并没有向后兼容的历史负担。Java 在语法上也提供了对 Interface 等高级特性的 支持。在这一切的基础之上，Java 达到了无与伦比的明晰性，以及更浓厚的“OOP”的 气息。和 C++一样，Java 一开始就被设计成一种承担大规模程序开发的语言，因此它对 名 字 空 间 和 嵌 套 类 型 的 支 持 非 常 完 善 。 另 外 ， Java 支 持 基 于 RTTI 技 术 的 反 射 （Reflection）机制，在这一点上已经超越了 Object Pascal。因此，Java 在组件化方面做 得非常成功（JavaBean 就是成果） ，这又导致了 Java 在分布式计算技术上的成功。在过 去的几年中，随着网络的崛起，Java 获得了空前的成功。 但是，Java 并不是没有改进余地的。.NET/C#的出现有力地证明了这一点。 相比 Java，C#最大的改进可能就是在效率方面。和 Java 一样，C#是一种纯粹的面 向对象的编程语言， “一切都是对象” 。对于 Java 中的一些优秀的语言特征，例如单根继 承结构、Interface 和 Reflection 等，C#也照单全收。但是，C#至少在以下几点上跟 Java 有着显著的不同： C# 大幅度地提高了值类型（Value Types）的重要性。值类型是和引用类型 （Reference Types）相对应而言的。在处理大对象的情况下，引用类型比值类 型更有效率，对于小型的、频繁的对象创建，使用值类型远比引用类型更有效 率。在 Java 中，除了基本类型以外，所有的变量都是引用类型。C#中的值类 型包含基本类型和 Struct，它们都派生自 System.ValueType，可以统一地被作为 对象处理。和 Class 的区别在于，Struct 是一种值类型，在栈中创建，而且是隐 式地封闭的 （Sealed） 因此比 Class 更有效率， ， 可以作为一种轻量级的 Class 来 使用。 C#提供了一些和 OOP 没有直接关系，但在实际应用中非常有用的语法特征， 例如对枚举 （Enum ） 委托(Delegate)、 （Property） 预处理器 、 属性 、 （Preprocessor） 的支持。 另外， C#还引入了一些 C++支持而 Java 和多播事件 （Mutilcast Events） 不支持的特性，如运算符重载。 在 Java 中，所有的类都是可以被继承的。C#提供了封闭类（Sealed Class）的 功能。封闭类不能够被继承。封闭类可以使软件架构更为严谨，并且在运行期 更有效率。 C# 提供了对不安全代码（unsafe code）的支持。在不安全代码中，C# 提供了 更加低层的能力，可以使用 C 风格的指针（Pointer） ，直接对内存进行操作。 它的代价是失去了许多虚拟机上的特性，包括内存自动回收，类型安全，数组 越界检查。 可以明显地感觉到，C#和 Java 二者在很多方面相似，但 C#比 Java 更偏向实用性。 无论是对值类型的重视，对属性、委托和预处理器的支持，还是对不安全代码的支持， 都是跟 OOP 没有直接关系、甚至破坏 OOP 的“纯洁性” （例如预处理器） 、但是在实际 编码中又非常有用的特征。相比之下，Java 显得更学院派，整体风格更为纯粹，或者说 更为理想主义。对这二者的取舍，可能存在着不同的意见，但是无可置疑的是，在付出 某些付价之后，C#确实在效率上和简洁性上超过了 Java。 Delphi Language 是比 C#出现得更晚的语言， 也是我们进行比较的语言中和 C#最为 相似的语言。由于 CLS 的规定，上述 C#的特征几乎都可以适用于 Delphi Language。但 是，与 C#不同的地方是，Delphi Language 必须顾及与原来的 Object Pascal 的兼容性问 题。

相对于 Java 和 C#，Delphi Language 的特征可以总结如下： Delphi Language 保 留 了 原 有 的 .pas 文 件 格 式 ， 也 就 是 由 Interface 和 Implementation 组成的格式，这意味着类的声明和定义是分离的。这种风格可 以追溯到 C 和 C++。在 Java 和 C#中，类的声明和定义不再分开了。 Delphi Language 保留了全局变量和全局函数。.NET 是一个纯粹的面向对象的 编程模型，C#也是纯粹的面向对象的语言，但是 Delphi Language 里面仍然保 留了对全局变量和全局函数和支持，也就是仍然保持了面向过程编程的风格。 Delphi Language 支持 MetaClass，这是 Object Pascal 语言中的类引用（Class Reference）的一种变形。类引用是 Object Pascal 独有的特征，Object Pascal 通 过类引用保存类的原始信息，并据此实现多态和 RTTI 等功能。.NET CLS 中没 有与类引用相对应的功能，因此 Delphi Language 引入了 MetaClass 的概念，通 过编译器隐式地为每一个类加入一个嵌套类，在这个嵌套类中保存着类的原始 信息。当需要类引用时，就从嵌套类中获取有关信息。 Object Pascal，或者说 Pascal 的严谨和强类型的风格，在 Delphi Language 中也 得到了体现。在 C#中，Boxing/Unboxing 可以通过直接在不同类型之间进行赋 值来执行，但在 Delphi Language 中，必须通过更为严谨的方式，即显式造型来 完成。 总结这些特征，我们可以得出一个大致的印象。由于必须符合.NET CLS 的规范， Delphi Language 进行了较大的扩展，支持许多高级的 OO 特性，从而使它在语言层次 上已经达到了与 Java 和 C#同样的水平。前文中已经说过，相比 Java，C#更倾向于实用 性，在这一点上，Delphi Language 比 C#有过之无不及。造成这一点的原因有两个，一 个是因为 Delphi Language 不象 C#那样是一种完全重新发明的语言，它必须照顾到向下 的兼容性；另一个是因为 Delphi Language，或者说 Object Pascal，从一开始就是一种针 对实际应用的语言，它的目标一直是如何方便而有效地满足用户需要，而不是符合某种 特定的理论。

总 结 C++的直接前驱是 C 语言，C 是一种灵活性极大的语言，与硬件层关系紧密，因此 被称为“可移植的汇编语言” ，也被称为“中级语言” （与汇编这样的低级语言，以及 Basic、Pascal 这样的高级语言相对而言） 。C 提供了对汇编的一种抽象，使得不同平台 之间的 C 语言的互相移植成为可能。同时，它的面向过程的特征，提供了模块化编程的 能力，从而有利于大规模的软开发工作。 C++ 将 面向 对象 编程 和泛型 编程 的思 想引 入了 C 语 言， 这些 特征分 别来自 Smalltalk 和 Ada 等语言。这些特征的加入，使得 C++成为比 C 语言更高层次的抽象。 这种抽象使得 C++具有更高程度的移植性，也更适合开发大规模的软件。但同时，由于 C++需要向下兼容 C，使得它残留了许多 C 的不好的特征。C++的出现，可以视为 C 向 更高层次的抽象的不那么彻底的尝试。 继 C++之后， Object Pascal 作为 Pascal 进行的同类尝试的产物出现了。 Object Pascal 针对 C++的成功与失败之处进行了改进， 改善了 OO 的机制， 抛弃或简化了其中某些过 于复杂或不贴近实用的设计， 并在此基础之上建立了自己的 IDE 和组件机制。 相比 C++， Object Pascal 并没有试图进行进一步的抽象， 但是作为一种轻量级、 实用性极强的语言， 它在应用领域获得了极大的成功。

Java 的诞生比 Object Pascal 略早，但是与 Object Pascal 相反，Java 正是向更彻底 的抽象努力的产物。Java 通过虚拟机使它彻底地独立于任何平台，通过语法和 API 的强 制贯彻了完整的 OO 思想，通过内存自动回收机制将原来由程序员完成的工作交给了虚 拟机本身。Java 彻底地改变了编程模型。由于 Java 是如此激进，因此它在诞生的前几 年并没有得到普遍的接受，随后又由于同一原因获得了空前的成功，这可能是它的发明 者自己也没有预料到的。 但是，历史并未就此终结。C#的出现，表示着对这一努力的某些过激之处的矫正。 C#与 Java 在许多方面非常近似，但是，C#重新将实用性而不是理论放在第一位。对值 类型的重视，对枚举、委托、属性、运算符重载、预处理器等特征的支持，都使得 C# 充满了更多的 C++或 Object Pascal 的气味。这是从 Java 的抽象层次往后退了一步。 Delphi Language 的特征与 C#非常类似， 如果说有区别的话， 那就是 Delphi Language 更注重实用性，保留了许多与 Object Pascal 兼容的特性，因此位于更低的抽象层次上。 如果将 C/C++和 Java 看做两个极端，那么 C# 就位于这两个极端中间，而 Delphi Language 又位于 C#和 C/C++ 中间。 我们也许可以作出如下结论： 近年来计算机编程语言的演变， 是一个从具体到抽象、 再从抽象到具体有所回归的过程。 编程语言本身就是人们企图对计算机硬件进行抽象的 产物，随着软件的规模越来越大，编程语言也越来越复杂，抽象的层次越来越高。面向 对象编程理论和泛型编程理论都是这种努力的成就， 它们能够帮助编程语言达到更高的 抽象层次。但是，从哲学的角度来说，人类的理性有其极限。试图用某种统一的方式对 整个世界进行全面的解释的努力，固然是一种诱惑，但最后都不能避免失败的命运。抽 象的层次越高，规范越严格，就会离硬件越远，牺牲越多的效率，最终不但远离了硬件， 甚至也已经偏离了人类的自然思维方式，偏离了抽象原本要达到的目标。在 Java 达到 了某种抽象的极限之后，C# 和 Delphi Language 的出现是对这一理想化的倾向的反动。

