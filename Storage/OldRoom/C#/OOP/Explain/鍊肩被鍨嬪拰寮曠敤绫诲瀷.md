---
title: 值类型和引用类型.md
date: 2016-08-17
tags: [C#]
categories: Language
---

`c#`的一个优点是不需要为内存管理操心，垃圾回收器会自动执行内存管理工作，这使得我们可以得到`C++`那样的效率，而免去`C++`那样的复杂性。

变量的作用域（生存周期）一般从定义之处开始，到代码块末尾结束，一旦作用域结束，变量就从内存中清除。

内存中有一个区域称为“栈”，用来存储‘整型， 实型， 布尔型， 字符型等基本类型数据’。

栈对数据的操作总发生在栈的顶部，最后入栈的变量最先弹出，最先入栈的数据最后弹出，因此先入栈的数据的作用域总比后入栈的数据作用域长，栈的这种工作方式称为‘后入先出’。

栈有非常高的性能，但栈中的变量的生存周期都是嵌套，创建变量的方法结束后，变量的生存周期也随之结束了。

但是，我们希望成员变量被构造函数初始化后，即使退出构造函数，这些变量仍然存在，以便在需要的时候使用，为此，`c#`把类的成员变量存储在‘堆’上。

堆和栈的工作方式截然不同。

创建类的对象分俩步：
- 先在堆中创建对象：系统在堆中划分一块`20`字节的空间用于存储对象的成员变量，并调用构造函数初始化它们，这样一个对象就创建了。
- 然后在栈中创建引用符： 系统在栈中分配`4`字节的空间，存储`graefield`对象在堆中的首地址。这种存储在栈中的指向堆中对象的地址称为`引用符`。系统通过`引用符`找到堆中的对象。

这种存储在堆中的对象称为 -- 引用型变量。

创建引用型变量比创建值类型的变量要复杂的多，虽然它会造成一点点性能上的损失，但可以对数据的生存周期进行非常强大的控制。

---

## 引用类型和垃圾回收器

在实际程序中，可能会有多个引用符指向一个对象，当某个引用符退出作用域时，系统就会从栈中删除该引用符，当指向对象的所有引用符都被删除时，对象就被加入垃圾回收的候选名单，垃圾回收器会在适当的时间清除该对象。只要存在指向对象的引用符，就不会删除对象。

传统的堆因为不停的创建和删除对象，导致堆中的自由内存空间不连续，但创建新对象时，只好在堆中搜索，直到找到一块足够的自由空间，这个搜索过程会花费一定时间。

`.NET`使用的是托管堆，托管堆和传统堆不同，当垃圾回收器清除一个对象后，垃圾回收器会推动堆中的其他对象。使它们连续的排列在堆的底部。并用一个堆指针指向空闲空间。当创建对象时，系统根据堆指针直接找到自由空间。

---

## 引用符和对象的区别

`Cube index` 这只是声明了一个对象的名称，仅仅在栈中创建了一个引用符而已，并没有真正的在堆中创建对象，对象的各个成员是不存在的，引用符中存储的是空地址。

只有使用`new`运算符后，对象才真正在堆中创建，才能使用它的成员。

当对象没有实例化时候，引用符的值为空`null`，当对象实例化后，引用符的值就是该对象在堆中的地址。通过引用符中存储的地址，系统可以轻易的找到在堆中的对象。

```c#
Cube index;
Cube c1 = new Cube(11,22,33);
index = c1;
Console.WriteLine("{0} {1} {2}", index[0], index[1], index[2]);
Cube c2 = new Cube(21, 32, 43);
index = c2;
Console.WriteLine("{0} {1} {2}", index[0], index[1], index[2]);
```

---

## 对象相等

`Object`类的成员有`4`种进行相等比较的方式。

1. `ReferenceEquals()` -- 引用比较，如果俩个引用指向堆中的同一个对象，或者是俩个引用的值都是`null`空地址时候返回`true`，否则返回`false`；这是一个静态方法。

2. 实例`Equals()` -- 只进行引用比较，但我们会在派生类中重写该方法，以实现值比较。如果俩个对象时值类型，则进行值比较；如果俩个对象时引用类型，则判断俩个对象的数据成员是否相等。

3. 静态`Equals()` -- 与实例版`Equals`完全相同，只是在调用`objA.Equals(objB)`前，会检查俩个参数是否为空，如果均为空引用，则返回`true`， 如果一个为空，一个不为空，则返回`false`；

4. 相等运算符== -- 若俩个对象为值类型，则比较来个对象的值；若俩个对象为引用类型，则比较俩个引用符。

一般情况下，使用`ReferenceEquals`进行引用比较，使用`Equals`进行值比较。

---

## 以对象为元素的数组

声明以对象为元素的数组方式和普通数组相同：
`Cat[] cats = new Cat[5]`
但上面的只是声明了一组`引用符`而已，并没有真正创建对象。
下面的语句才具体创建对象，并让每个引用符指向一个对象

```c#
for(int i = 0; i < cats.Length; i++)
{
    cats[i] = new Cat();
}
```

上面这样就在内存中创建对象了。

也可以像普通数组那样，声明和初始化同时进行。
`Cat[] cats = new Cat[] {new Cat("kitty", 2), new Cat("tom", 3)}`;

---

## 匿名类型

有时候某些类在程序中只会使用一次，这时候就没必要单独为它创建一个类，就可以使用匿名类型简洁很多。

```c#
var city = new {Name = "BJ", Code = 0001};
Console.WriteLine(city.Name + "\n" + city.Code);
```

匿名类型只能由一个或多个只读属性组成，不能包含其他种类的类成员，编译时，编译器会自动生成相关的类，并创建一个该类的对象以供使用。

---

## 扩展类型

很多时候在已经编译好的类型中添加新的功能，比如在`Double`类型中添加一个计算次方的方法`Power()`，你可能会想到去创建一个派生类，但使用起来往往不方便，可以使用`c#3.0`添加的新功能--‘扩展方法’；
`public static double Power(this double x, int exp){}`
`Power` -- 要扩展的的方法名称，
`double` -- 想要扩展的类

扩展方法的第一个参数的类型就是该方法想要扩展的类，必须用`this`关键字修饰，扩展方法是静态方法，但调用的时候只能用对象来调用。

扩展类型的类文件
```c#
namespace ExtensionMethods
{
    public static class MyExtensions
    {
        public static double Power(this double x, int exp)
        {
            double result = 1;
            for (int i = 1; i <= exp; i++)
            {
                result *= x;
            }
            return result;
        }
    }
}
```

调用扩展类型时候或者说是引入扩展类型时候，需要使用`using`引入命名空间。然后就可以在`double`类中使用`Power`方法。

```c#
using ExtensionMethods;
class Program
    {
        static void Main(string[] args)
        {
            double x = 2.478;
            double y = x.Power(3);
            Console.WriteLine(y);
        }
    }
```

在使用扩展方法的时候，要应用定义扩展方法的命名空间。扩展方法只能定义在静态类中，与以往静态方法不同的是，从使用者角度来看已经不用关心这个方法是来自那个类，主要记着命名空间就可以。所以我们经常把所有扩展方法放在同一个命名空间里。